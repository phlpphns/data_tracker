Ich gehe davon aus, dass in den rodhypix files der string TY6 in case 6 (siehe zB in Zeile 121) "geparst" wird und dann die Routine dementsprechend verfolgt.

Ich konnte die folgenden Funktionen, die damit im Zusammenhang stehen, identifizieren:

pPrepareHeaderSAPPHIRE_FORMAT_COMMON
ODC::pLoadIFormatsHeaderDefaultODC
pGetInfoIformatDllSAPPHIRE
sGetSapphireCompressionTypeSAPPHIRE
pSetSapphireCompressionTypeSAPPHIRE
iReadImageHeaderSAPPHIRE
iReadImageHeaderSAPPHIRE_FORMAT_COMMON
iReadImageSAPPHIRE_FORMAT_COMMON
pImageCompressionSAPPHIRE_FORMAT_COMMON
pImageDecompressionSAPPHIRE_FORMAT_COMMON(
lImageCompressionParallelBitfieldSAPPHIRE_FORMAT_COMMON
pImageDecompressionBitfieldParallelSAPPHIRE_FORMAT
sub_100551C0


==============================================================================================================================
void __cdecl pPrepareHeaderSAPPHIRE_FORMAT_COMMON(
        struct ODC::iformats_header_tag *a1,
        __int16 a2,
        struct ODM::image_tag *a3,
        int a4)
{
  bool v4; // zf
  int v5; // eax
  double v6; // st7
  int v7; // eax
  double v8; // st7
  double v9; // st6
  double v10; // st7
  int v11; // eax
  double v12; // st7
  double v13; // st6
  int v14; // eax
  char *v15; // eax
  char *v16; // edx
  char v17; // cl
  __time64_t Time; // [esp+14h] [ebp-34h] BYREF
  struct ODM::image_tag *v19; // [esp+1Ch] [ebp-2Ch]
  float v20; // [esp+20h] [ebp-28h]
  char Buffer[32]; // [esp+24h] [ebp-24h] BYREF

  v4 = *((_BYTE *)a3 + 86841) == 0;
  v19 = a3;
  if ( v4 )
    sprintf(Buffer, "%3.1f", 3.0);
  else
    sprintf(Buffer, "%3.1f", 4.0);
  strncpy((char *)a1 + *((__int16 *)a1 + 128), Buffer, 3u);
  sprintf(Buffer, "%4d", *((__int16 *)v19 + 13));
  strncpy((char *)a1 + *((__int16 *)a1 + 131), Buffer, 4u);
  sprintf(Buffer, "%4d", *((__int16 *)v19 + 14));
  strncpy((char *)a1 + *((__int16 *)a1 + 132), Buffer, 4u);
  switch ( a2 )
  {
    case 0:
      sprintf(Buffer, "TY1");
      strncpy((char *)a1 + *((__int16 *)a1 + 129), Buffer, 3u);
      sprintf(Buffer, "%7d", *((_DWORD *)a1 + 72));
      strncpy((char *)a1 + *((__int16 *)a1 + 133), Buffer, 7u);
      sprintf(Buffer, "%7d", *((_DWORD *)a1 + 73));
      strncpy((char *)a1 + *((__int16 *)a1 + 134), Buffer, 7u);
      v5 = *((_DWORD *)v19 + 9) * *((__int16 *)v19 + 20);
      v20 = (double)(v5 + 2 * (*((_DWORD *)a1 + 72) + 2 * *((_DWORD *)a1 + 73))) * 100.0 / (double)(4 * v5);
      v6 = v20;
      *((float *)a1 + 78) = v20;
      sprintf(Buffer, "(%5.1f%)", v6);
      strncpy((char *)a1 + *((__int16 *)a1 + 130), Buffer, 8u);
      break;
    case 1:
      sprintf(Buffer, " NO");
      strncpy((char *)a1 + *((__int16 *)a1 + 129), Buffer, 3u);
      sprintf(Buffer, "%7d", 0);
      strncpy((char *)a1 + *((__int16 *)a1 + 133), Buffer, 7u);
      sprintf(Buffer, "%7d", 0);
      strncpy((char *)a1 + *((__int16 *)a1 + 134), Buffer, 7u);
      sprintf(Buffer, "        ");
      strncpy((char *)a1 + *((__int16 *)a1 + 130), Buffer, 8u);
      break;
    case 2:
      sprintf(Buffer, "TY2");
      strncpy((char *)a1 + *((__int16 *)a1 + 129), Buffer, 3u);
      sprintf(Buffer, "%7d", 0);
      strncpy((char *)a1 + *((__int16 *)a1 + 133), Buffer, 7u);
      sprintf(Buffer, "%7d", 0);
      strncpy((char *)a1 + *((__int16 *)a1 + 134), Buffer, 7u);
      v9 = (double)(4 * *((_DWORD *)v19 + 9));
      if ( ((2 * *((_DWORD *)v19 + 9)) & 0x40000000) != 0 )
        v9 = v9 + 4294967296.0;
      v20 = (double)a4 * 100.0 / v9;
      v10 = v20;
      goto LABEL_16;
    case 3:
      sprintf(Buffer, "TY3");
      strncpy((char *)a1 + *((__int16 *)a1 + 129), Buffer, 3u);
      sprintf(Buffer, "%7d", *((_DWORD *)a1 + 72));
      strncpy((char *)a1 + *((__int16 *)a1 + 133), Buffer, 7u);
      sprintf(Buffer, "%7d", *((_DWORD *)a1 + 73));
      strncpy((char *)a1 + *((__int16 *)a1 + 134), Buffer, 7u);
      v7 = *((_DWORD *)v19 + 9) * *((__int16 *)v19 + 20);
      v20 = (double)(v7 + 2 * (*((_DWORD *)a1 + 72) + 2 * *((_DWORD *)a1 + 73))) * 100.0 / (double)(4 * v7);
      v8 = v20;
      *((float *)a1 + 78) = v20;
      sprintf(Buffer, "(%5.1f%)", v8);
      strncpy((char *)a1 + *((__int16 *)a1 + 130), Buffer, 8u);
      break;
    case 5:
      sprintf(Buffer, "TY5");
      strncpy((char *)a1 + *((__int16 *)a1 + 129), Buffer, 3u);
      sprintf(Buffer, "%7d", *((_DWORD *)a1 + 72));
      strncpy((char *)a1 + *((__int16 *)a1 + 133), Buffer, 7u);
      sprintf(Buffer, "%7d", *((_DWORD *)a1 + 73));
      strncpy((char *)a1 + *((__int16 *)a1 + 134), Buffer, 7u);
      v11 = *((_DWORD *)v19 + 9) * *((__int16 *)v19 + 20);
      v20 = (double)(v11 + 2 * (*((_DWORD *)a1 + 72) + 2 * *((_DWORD *)a1 + 73))) * 100.0 / (double)(4 * v11);
      v10 = v20;
      goto LABEL_16;
    case 6:
      sprintf(Buffer, "TY6");
      strncpy((char *)a1 + *((__int16 *)a1 + 129), Buffer, 3u);
      sprintf(Buffer, "%7d", *((_DWORD *)a1 + 72));
      strncpy((char *)a1 + *((__int16 *)a1 + 133), Buffer, 7u);
      sprintf(Buffer, "%7d", *((_DWORD *)a1 + 73));
      strncpy((char *)a1 + *((__int16 *)a1 + 134), Buffer, 7u);
      v12 = (double)a4 * 100.0;
      v13 = (double)(4 * *((_DWORD *)v19 + 9) * *((__int16 *)v19 + 20));
      goto LABEL_15;
    case 7:
      sprintf(Buffer, "TY7");
      strncpy((char *)a1 + *((__int16 *)a1 + 129), Buffer, 3u);
      sprintf(Buffer, "%7d", *((_DWORD *)a1 + 72));
      strncpy((char *)a1 + *((__int16 *)a1 + 133), Buffer, 7u);
      sprintf(Buffer, "%7d", *((_DWORD *)a1 + 73));
      strncpy((char *)a1 + *((__int16 *)a1 + 134), Buffer, 7u);
      v12 = (double)a4 * 100.0;
      v13 = (double)(4 * *((_DWORD *)v19 + 9) * *((__int16 *)v19 + 20));
      goto LABEL_15;
    case 8:
      sprintf(Buffer, "TY8");
      strncpy((char *)a1 + *((__int16 *)a1 + 129), Buffer, 3u);
      sprintf(Buffer, "%7d", *((_DWORD *)a1 + 72));
      strncpy((char *)a1 + *((__int16 *)a1 + 133), Buffer, 7u);
      sprintf(Buffer, "%7d", *((_DWORD *)a1 + 73));
      strncpy((char *)a1 + *((__int16 *)a1 + 134), Buffer, 7u);
      v12 = (double)a4 * 100.0;
      v13 = (double)(4 * *((_DWORD *)v19 + 9) * *((__int16 *)v19 + 20));
LABEL_15:
      v20 = v12 / v13;
      v10 = v20;
LABEL_16:
      *((float *)a1 + 78) = v10;
      sprintf(Buffer, "(%5.1f%)", v10);
      strncpy((char *)a1 + *((__int16 *)a1 + 130), Buffer, 8u);
      break;
    default:
      break;
  }
  sprintf(Buffer, "%7d", 512);
  strncpy((char *)a1 + *((__int16 *)a1 + 136), Buffer, 7u);
  sprintf(Buffer, "%7d", 768);
  strncpy((char *)a1 + *((__int16 *)a1 + 137), Buffer, 7u);
  sprintf(Buffer, "%7d", 1024);
  strncpy((char *)a1 + *((__int16 *)a1 + 138), Buffer, 7u);
  sprintf(Buffer, "%7d", 512);
  strncpy((char *)a1 + *((__int16 *)a1 + 139), Buffer, 7u);
  LODWORD(v20) = 5120;
  sprintf(Buffer, "%7d", 2048);
  strncpy((char *)a1 + *((__int16 *)a1 + 140), Buffer, 7u);
  v14 = 6576;
  if ( !*((_BYTE *)v19 + 86841) )
    v14 = LODWORD(v20);
  sprintf(Buffer, "%7d", v14);
  strncpy((char *)a1 + *((__int16 *)a1 + 135), Buffer, 7u);
  sprintf(Buffer, "%7d", 0);
  strncpy((char *)a1 + *((__int16 *)a1 + 141), Buffer, 7u);
  Time = time64(0);
  v15 = ctime64(&Time);
  v16 = (char *)(Buffer - v15);
  do
  {
    v17 = *v15;
    v16[(_DWORD)v15] = *v15;
    ++v15;
  }
  while ( v17 );
  strncpy((char *)a1 + *((__int16 *)a1 + 142), Buffer, 0x18u);
  *((_BYTE *)a1 + 255) = 26;
}
==============================================================================================================================
void __cdecl ODC::pLoadIFormatsHeaderDefaultODC(ODC *this)
{
  _DWORD v1[91]; // [esp+8h] [ebp-16Ch] BYREF

  strcpy(
    (char *)v1,
    "OD SAPPHIRE  X.X\r\n"
    "COMPRESSION= NO(100.0%)\r\n"
    "NX=XXXX NY=XXXX OI=XXXXXXX OL=XXXXXXX \r\n"
    "NHEADER=XXXXXXX NG=XXXXXXX NS=XXXXXXX NK=XXXXXXX NS=XXXXXXX NH=XXXXXXX\r\n"
    "NSUPPLEMENT=XXXXXXX\r\n"
    "TIME=Sun Nov 09 00:00:00 1989                                                  ");
  *(float *)&v1[78] = 0.0;
  *(float *)&v1[80] = 0.0;
  LOWORD(v1[71]) = 181;
  v1[64] = 1966093;
  v1[65] = 3014689;
  v1[66] = 4063286;
  v1[67] = 5963849;
  v1[68] = 7405670;
  v1[69] = 8847484;
  v1[70] = 10944658;
  memset(&v1[72], 0, 22);
  v1[79] = 0;
  memset(&v1[81], 0, 40);
  qmemcpy(this, v1, 0x16Cu);
}
==============================================================================================================================
void __cdecl pGetInfoIformatDllSAPPHIRE(struct iformat_tag *a1)
{
  *((_DWORD *)a1 + 471) = 65537;
  *((_WORD *)a1 + 944) = 1;
  *((_DWORD *)a1 + 476) = 65537;
  *((_WORD *)a1 + 954) = 1;
  strcpy((char *)a1 + 308, "sapphire");
  strcpy((char *)a1 + 570, "SAPPHIRE");
  *((_DWORD *)a1 + 141) = 0;
}
==============================================================================================================================
int sGetSapphireCompressionTypeSAPPHIRE()
{
  return dword_100A02E0;
}
==============================================================================================================================
int __cdecl pSetSapphireCompressionTypeSAPPHIRE(int a1)
{
  int result; // eax

  result = a1;
  dword_100A02E0 = a1;
  return result;
}
==============================================================================================================================
__int16 __cdecl iReadImageHeaderSAPPHIRE(
        LPARAM lParam,
        char *FileName,
        char *a3,
        struct ODM::image_tag *a4,
        struct ODC::iformats_header_tag *a5)
{
  return iReadImageHeaderSAPPHIRE_FORMAT_COMMON(lParam, FileName, a3, a4, a5, 0);
}
==============================================================================================================================
int __cdecl iReadImageHeaderSAPPHIRE_FORMAT_COMMON(
        struct ODM::error_tag *lParam,
        char *FileName,
        char *a3,
        struct ODM::image_tag *a4,
        struct ODC::iformats_header_tag *a5)
{
  void *v5; // esp
  LPARAM v6; // ebx
  FILE *v7; // edi
  __int16 v9; // ax
  char *v10; // [esp-8h] [ebp-15A44h]
  char *v11; // [esp-4h] [ebp-15A40h]
  char *v12; // [esp-4h] [ebp-15A40h]
  char *v13; // [esp-4h] [ebp-15A40h]
  _DWORD Src[22078]; // [esp+28h] [ebp-15A14h] BYREF
  char Buffer[256]; // [esp+15920h] [ebp-11Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+15A24h] [ebp-18h] BYREF

  v5 = alloca(88588);
  ms_exc.registration.ScopeTable = (PSCOPETABLE_ENTRY)((int)ms_exc.registration.ScopeTable ^ __security_cookie);
  v6 = (LPARAM)lParam;
  memset(Buffer, 0, sizeof(Buffer));
  v7 = fopen(FileName, "rb");
  if ( !v7 )
  {
    sprintf(Buffer, "CAN'T OPEN FILE %s (iReadImageHeaderSAPPHIRE_FORMAT_COMMON)", FileName);
    ODM::pAddErrorStringODM((LPARAM)lParam, (struct ODM::error_tag *)Buffer, v11);
    return 0;
  }
  ms_exc.registration.TryLevel = 0;
  if ( !(unsigned __int16)sub_10058A40(a5) )
  {
    sprintf(Buffer, "PROBLEMS READING THE ASCII HEADER FROM %s (iReadImageHeaderSAPPHIRE_FORMAT_COMMON)", FileName);
    ODM::pAddErrorStringODM((LPARAM)lParam, (struct ODM::error_tag *)Buffer, v12);
    local_unwind4(&__security_cookie, &ms_exc.registration, -2);
    return 0;
  }
  if ( !iInterpreteASCIIHeaderSAPPHIRE_FORMAT_COMMON(lParam, a5) )
  {
    local_unwind4(&__security_cookie, &ms_exc.registration, -2);
    return 0;
  }
  memset(Src, 0, sizeof(Src));
  if ( 2.0 == *((float *)a5 + 80) )
  {
    v9 = sub_10058590(v7);
    v6 = (LPARAM)lParam;
  }
  else if ( 3.0 == *((float *)a5 + 80) )
  {
    v9 = sub_100587F0(v7, Src);
  }
  else
  {
    if ( 4.0 != *((float *)a5 + 80) )
    {
      sprintf(
        Buffer,
        "IMAGE VERSION (%10.2f) NOT SUPPORTED (iReadImageHeaderSAPPHIRE_FORMAT_COMMON)",
        *((float *)a5 + 80));
      ODM::pAddErrorStringODM((LPARAM)lParam, (struct ODM::error_tag *)Buffer, v10);
      local_unwind4(&__security_cookie, &ms_exc.registration, -2);
      return 0;
    }
    v9 = sub_10058900(v7, Src);
  }
  if ( v9 )
  {
    qmemcpy(&Src[82], Src, 0x148u);
    qmemcpy(&Src[326], (char *)a4 + 1304, 0x38u);
    Src[22074] = *((_DWORD *)a4 + 22074);
    memcpy(a4, Src, 0x158F8u);
    pCalculateCameraParametersUC(a4);
    ms_exc.registration.TryLevel = -2;
    fclose(v7);
    return 1;
  }
  else
  {
    sprintf(Buffer, "PROBLEMS READING THE HEADER FROM %s (iReadImageHeaderSAPPHIRE_FORMAT_COMMON)", FileName);
    ODM::pAddErrorStringODM(v6, (struct ODM::error_tag *)Buffer, v13);
    local_unwind4(&__security_cookie, &ms_exc.registration, -2);
    return 0;
  }
}
==============================================================================================================================
int __cdecl iReadImageSAPPHIRE_FORMAT_COMMON(
        struct ODM::error_tag *a1,
        struct ODM::prog_tag *a2,
        char *a3,
        struct ODM::image_tag *a4,
        struct ODC::iformats_header_tag *a5,
        char *a6,
        __int16 (__cdecl *a7)(struct ODM::error_tag *, __int16, __int16, int, __int16, __int16, int, struct sapphire_decompressioninfo_tag *, __int16),
        __int16 (__cdecl *a8)(struct ODM::error_tag *, struct ODM::image_tag *, struct sapphire_decompressioninfo_tag **, int *, __int16, __int16, __int16 (__cdecl *)(struct ODM::error_tag *, __int16, __int16, int, __int16, __int16, int, struct sapphire_decompressioninfo_tag *, __int16), __int16 (__cdecl *)(struct ODM::error_tag *, struct sapphire_decompressioninfo_tag *)),
        __int16 (__cdecl *a9)(struct ODM::error_tag *, struct sapphire_decompressioninfo_tag *),
        __int16 a10)
{
  ODM *v10; // ebx
  char *v12; // edx
  char v13; // al
  int v15; // eax
  const char *v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // ecx
  ODM *v20; // eax
  __int16 v21; // ax
  size_t v22; // esi
  int *v23; // eax
  unsigned int i; // ecx
  char *v25; // [esp-Ch] [ebp-16Ch]
  char *v26; // [esp-Ch] [ebp-16Ch]
  char *v27; // [esp-Ch] [ebp-16Ch]
  char *v28; // [esp-Ch] [ebp-16Ch]
  int v29; // [esp-8h] [ebp-168h]
  char *v30; // [esp-8h] [ebp-168h]
  struct ODC::iformats_header_tag *v31; // [esp+24h] [ebp-13Ch] BYREF
  const char *v32[2]; // [esp+28h] [ebp-138h] BYREF
  ODM *v33; // [esp+30h] [ebp-130h]
  int Buffer; // [esp+34h] [ebp-12Ch] BYREF
  FILE *Stream; // [esp+38h] [ebp-128h]
  ODM *v36; // [esp+3Ch] [ebp-124h]
  char FileName[260]; // [esp+40h] [ebp-120h] BYREF
  CPPEH_RECORD ms_exc; // [esp+148h] [ebp-18h] BYREF

  v10 = a1;
  v36 = a1;
  v33 = a2;
  v32[1] = (const char *)a4;
  v31 = a5;
  v32[0] = a6;
  Buffer = 0;
  memset(FileName, 0, sizeof(FileName));
  if ( a6 )
  {
    sprintf((char *const)a1 + 27260, "%s", v32[0]);
    ODM::pProgressMessageODM_UP(v33, (struct ODM::error_tag *)((char *)a1 + 27260), v25);
  }
  ms_exc.registration.TryLevel = 0;
  v12 = FileName;
  do
  {
    v13 = *a3;
    *v12++ = *a3++;
  }
  while ( v13 );
  Stream = fopen(FileName, "rb");
  if ( !Stream )
  {
    sprintf((char *const)a1 + 27260, "CAN'T OPEN FILE %s (iReadImageSAPPHIRE_FORMAT_COMMON-sapphire)", FileName);
    ODM::pAddErrorStringODM((LPARAM)a1, (struct ODM::error_tag *)((char *)a1 + 27260), v26);
    ms_exc.registration.TryLevel = -2;
    return 0;
  }
  ms_exc.registration.TryLevel = 2;
  if ( 2.0 == *((float *)a5 + 80) )
  {
    fseek(Stream, 4608, 0);
  }
  else
  {
    if ( 4.0 == *((float *)a5 + 80) )
      v29 = 6576;
    else
      v29 = 5120;
    fseek(Stream, v29, 0);
  }
  ms_exc.registration.TryLevel = 1;
  v15 = *((unsigned __int16 *)a5 + 176);
  switch ( (__int16)v15 )
  {
    case 0:
    case 3:
    case 5:
    case 6:
    case 7:
    case 8:
      v32[0] = 0;
      if ( !a8(a1, a4, (struct sapphire_decompressioninfo_tag **)v32, 0, 0, v15, a7, a9) )
        goto LABEL_23;
      ms_exc.registration.TryLevel = 3;
      v16 = v32[0];
      *((_DWORD *)a5 + 74) = *((_DWORD *)v32[0] + 5);
      *((_DWORD *)a5 + 75) = *((_DWORD *)v16 + 6);
      *((_DWORD *)a5 + 76) = *((_DWORD *)v16 + 7);
      *((_DWORD *)a5 + 90) = *((_DWORD *)v16 + 9);
      v17 = *((__int16 *)a5 + 176);
      if ( v17 == 5 )
      {
        v21 = sub_10057B70(Stream);
      }
      else
      {
        if ( (unsigned int)(v17 - 6) <= 2 )
        {
          if ( fread(&Buffer, 4u, 1u, Stream) == 1 )
          {
            if ( *((_WORD *)a5 + 176) != 8 )
            {
              v33 = (ODM *)(*((_DWORD *)a4 + 9) * *((__int16 *)a4 + 20));
              if ( Buffer <= (int)((unsigned int)v33 >> 3) )
                goto LABEL_23;
              v18 = *((__int16 *)a4 + 14);
              v19 = Buffer;
              if ( Buffer > 2 * ((int)v33 + 2 * v18 + 2 * *((_DWORD *)a5 + 73) + *((_DWORD *)a5 + 72)) )
                goto LABEL_23;
LABEL_24:
              v33 = (ODM *)(v19 + 4 * v18);
              v20 = (ODM *)fread(*((void **)a5 + 74), 1u, (size_t)v33, Stream);
              if ( v20 == v33 )
                goto LABEL_25;
              goto LABEL_29;
            }
            v18 = *((__int16 *)a4 + 14);
            v19 = Buffer;
            if ( Buffer <= 2
                         * (*((_DWORD *)a5 + 72)
                          + *((_DWORD *)a4 + 9) * *((__int16 *)a4 + 20)
                          + 2 * (v18 + *((_DWORD *)a5 + 73))) )
              goto LABEL_24;
          }
LABEL_23:
          local_unwind4(&__security_cookie, &ms_exc.registration, -2);
          return 0;
        }
        v21 = sub_10057AF0();
        v10 = v36;
      }
      if ( v21 )
      {
LABEL_25:
        ms_exc.registration.TryLevel = 1;
        ms_exc.registration.TryLevel = 4;
        switch ( *((_WORD *)a5 + 176) )
        {
          case 3:
            pImageDecompressionLinearSAPPHIRE_FORMAT_COMMON(a4, a5);
            ms_exc.registration.TryLevel = 1;
            break;
          case 5:
            pImageDecompressionVer2ParallelSAPPHIRE_FORMAT_COMMON(v10, a4, a5);
            ms_exc.registration.TryLevel = 1;
            break;
          case 6:
          case 7:
            pImageDecompressionBitfieldParallelSAPPHIRE_FORMAT_COMMON(v10, a4, a5, Buffer);
            ms_exc.registration.TryLevel = 1;
            break;
          case 8:
            pImageDecompressionBitfieldParallelType8SAPPHIRE_FORMAT_COMMON(v10, a4, a5, Buffer);
            ms_exc.registration.TryLevel = 1;
            break;
          default:
            pImageDecompressionSAPPHIRE_FORMAT_COMMON(a4, a5);
            goto LABEL_36;
        }
        goto LABEL_43;
      }
LABEL_29:
      sprintf(
        (char *const)v10 + 27260,
        "PROBLEMS READING COMPRESSED DATA FROM %s (iReadImageSAPPHIRE_FORMAT_COMMON-sapphire)",
        FileName);
      ODM::pAddErrorStringODM((LPARAM)v10, (ODM *)((char *)v10 + 27260), v27);
      local_unwind4(&__security_cookie, &ms_exc.registration, -2);
      return 0;
    case 1:
      ms_exc.registration.TryLevel = 5;
      v22 = *((_DWORD *)a4 + 9) * *((__int16 *)a4 + 20);
      if ( fread(*((void **)a4 + 22074), 4u, v22, Stream) != v22 )
        goto LABEL_38;
      goto LABEL_36;
    case 2:
      ms_exc.registration.TryLevel = 6;
      v31 = 0;
      if ( a8(a1, a4, &v31, 0, 0, v15, a7, a9) )
      {
        if ( iReadImageCCP4SAPPHIRE_FORMAT_COMMON(
               (LPARAM)a1,
               v33,
               FileName,
               a4,
               *((int **)v31 + 7),
               *((_DWORD *)v31 + 2)) )
        {
LABEL_36:
          ms_exc.registration.TryLevel = 1;
LABEL_43:
          if ( a10 )
          {
            v23 = (int *)*((_DWORD *)a4 + 22074);
            for ( i = 0; i < *((_DWORD *)a4 + 9); ++i )
            {
              if ( *v23 < -1 )
                *v23 = -999999999;
              ++v23;
            }
          }
          ms_exc.registration.TryLevel = 0;
          if ( Stream )
            fclose(Stream);
          return 1;
        }
        else
        {
LABEL_38:
          sprintf(
            (char *const)a1 + 27260,
            "PROBLEMS READING THE IMAGE DATA FROM %s (iReadImageSAPPHIRE_FORMAT_COMMON-sapphire)",
            FileName);
          ODM::pAddErrorStringODM((LPARAM)a1, (struct ODM::error_tag *)((char *)a1 + 27260), v28);
          local_unwind4(&__security_cookie, &ms_exc.registration, -2);
          return 0;
        }
      }
      else
      {
        local_unwind4(&__security_cookie, &ms_exc.registration, -2);
        return 0;
      }
    default:
      ms_exc.registration.TryLevel = 7;
      sprintf(
        (char *const)a1 + 27260,
        "Programming error: iiscompression neither TRUE nor FALSE - contact Rigaku Oxford Diffraction (sapphire_format_common.cpp)");
      ODM::pAddErrorStringODM((LPARAM)a1, (struct ODM::error_tag *)((char *)a1 + 27260), v30);
      ms_exc.registration.TryLevel = 1;
      local_unwind4(&__security_cookie, &ms_exc.registration, -2);
      return 0;
  }
}
==============================================================================================================================
void __cdecl pImageCompressionSAPPHIRE_FORMAT_COMMON(struct ODM::image_tag *a1, struct ODC::iformats_header_tag *a2)
{
  int v2; // esi
  int *v3; // edi
  _BYTE *v5; // edx
  int v6; // ecx
  int *v7; // ebx
  _BYTE *v8; // edx
  int v9; // ecx
  _DWORD *v10; // [esp+Ch] [ebp-4h]
  struct ODM::image_tag *v11; // [esp+18h] [ebp+8h]
  struct ODC::iformats_header_tag *v12; // [esp+1Ch] [ebp+Ch]
  struct ODC::iformats_header_tag *v13; // [esp+1Ch] [ebp+Ch]

  v2 = *((_DWORD *)a1 + 9) * *((__int16 *)a1 + 20);
  v3 = (int *)*((_DWORD *)a1 + 22074);
  v10 = v3 + 1;
  v5 = (_BYTE *)*((_DWORD *)a2 + 74);
  v11 = (struct ODM::image_tag *)*((_DWORD *)a2 + 75);
  v12 = (struct ODC::iformats_header_tag *)*((_DWORD *)a2 + 76);
  *((_DWORD *)a2 + 73) = 0;
  *((_DWORD *)a2 + 72) = 0;
  v6 = *v3;
  if ( (unsigned int)(*v3 + 127) > 0xFD )
  {
    if ( (unsigned int)(v6 + 0x8000) > 0xFFFF )
    {
      *v5 = -1;
      *(_DWORD *)v12 = v6;
      v7 = (int *)((char *)v12 + 4);
      ++*((_DWORD *)a2 + 73);
    }
    else
    {
      *v5 = -2;
      *(_WORD *)v11 = v6;
      ++*((_DWORD *)a2 + 72);
      v11 = (struct ODM::image_tag *)((char *)v11 + 2);
      v7 = (int *)v12;
    }
  }
  else
  {
    v7 = (int *)v12;
    *v5 = v6 + 127;
  }
  v8 = v5 + 1;
  if ( v2 > 1 )
  {
    v13 = (struct ODC::iformats_header_tag *)(v2 - 1);
    do
    {
      v9 = *v10 - *v3;
      if ( (unsigned int)(v9 + 127) > 0xFD )
      {
        if ( (unsigned int)(v9 + 0x8000) > 0xFFFF )
        {
          *v8 = -1;
          *v7++ = v9;
          ++*((_DWORD *)a2 + 73);
        }
        else
        {
          *v8 = -2;
          *(_WORD *)v11 = v9;
          ++*((_DWORD *)a2 + 72);
          v11 = (struct ODM::image_tag *)((char *)v11 + 2);
        }
      }
      else
      {
        *v8 = v9 + 127;
      }
      ++v10;
      ++v8;
      ++v3;
      v13 = (struct ODC::iformats_header_tag *)((char *)v13 - 1);
    }
    while ( v13 );
  }
}
==============================================================================================================================
void __cdecl pImageDecompressionSAPPHIRE_FORMAT_COMMON(struct ODM::image_tag *a1, struct ODC::iformats_header_tag *a2)
{
  unsigned __int8 *v3; // esi
  int v4; // edi
  int *v5; // eax
  unsigned __int8 v6; // bl
  int *v7; // ecx
  int v8; // ebx
  unsigned __int8 *v9; // esi
  __int16 v10; // bx
  int v11; // edi
  struct ODC::iformats_header_tag *v12; // ebx
  int v13; // edx
  struct ODM::image_tag *v14; // ebx
  int v15; // edx
  int v16; // edi
  unsigned __int8 v17; // dl
  struct ODM::image_tag *v18; // [esp+14h] [ebp+8h]
  struct ODM::image_tag *v19; // [esp+14h] [ebp+8h]
  struct ODC::iformats_header_tag *v20; // [esp+18h] [ebp+Ch]
  struct ODC::iformats_header_tag *v21; // [esp+18h] [ebp+Ch]

  v3 = (unsigned __int8 *)*((_DWORD *)a2 + 74);
  v4 = *((_DWORD *)a1 + 9) * *((__int16 *)a1 + 20);
  v5 = (int *)*((_DWORD *)a1 + 22074);
  v20 = (struct ODC::iformats_header_tag *)*((_DWORD *)a2 + 75);
  v18 = (struct ODM::image_tag *)*((_DWORD *)a2 + 76);
  v6 = *v3;
  v7 = v5 + 1;
  if ( *v3 == 0xFF )
  {
    v8 = *(_DWORD *)v18;
    v18 = (struct ODM::image_tag *)((char *)v18 + 4);
  }
  else if ( v6 == 0xFE )
  {
    v8 = *(__int16 *)v20;
    v20 = (struct ODC::iformats_header_tag *)((char *)v20 + 2);
  }
  else
  {
    v8 = v6 - 127;
  }
  *v5 = v8;
  v9 = v3 + 1;
  v10 = *((_DWORD *)a2 + 72) > 0;
  if ( *((int *)a2 + 73) > 0 )
    v10 += 2;
  switch ( v10 )
  {
    case 0:
      if ( v4 > 1 )
      {
        v11 = v4 - 1;
        do
        {
          *v7++ = *v9++ + *v5++ - 127;
          --v11;
        }
        while ( v11 );
      }
      break;
    case 1:
      if ( v4 > 1 )
      {
        v12 = v20;
        v19 = (struct ODM::image_tag *)(v4 - 1);
        do
        {
          if ( *v9 == 0xFE )
          {
            v13 = *v5 + *(__int16 *)v12;
            v12 = (struct ODC::iformats_header_tag *)((char *)v12 + 2);
          }
          else
          {
            v13 = *v9 + *v5 - 127;
          }
          *v7 = v13;
          ++v9;
          ++v5;
          ++v7;
          v19 = (struct ODM::image_tag *)((char *)v19 - 1);
        }
        while ( v19 );
      }
      break;
    case 2:
      if ( v4 > 1 )
      {
        v14 = v18;
        v21 = (struct ODC::iformats_header_tag *)(v4 - 1);
        do
        {
          if ( *v9 == 0xFF )
          {
            v15 = *(_DWORD *)v14 + *v5;
            v14 = (struct ODM::image_tag *)((char *)v14 + 4);
          }
          else
          {
            v15 = *v9 + *v5 - 127;
          }
          *v7 = v15;
          ++v9;
          ++v5;
          ++v7;
          v21 = (struct ODC::iformats_header_tag *)((char *)v21 - 1);
        }
        while ( v21 );
      }
      break;
    case 3:
      if ( v4 > 1 )
      {
        v16 = v4 - 1;
        do
        {
          v17 = *v9;
          if ( *v9 == 0xFF )
          {
            *v7 = *(_DWORD *)v18 + *v5;
            v18 = (struct ODM::image_tag *)((char *)v18 + 4);
          }
          else if ( v17 == 0xFE )
          {
            *v7 = *v5 + *(__int16 *)v20;
            v20 = (struct ODC::iformats_header_tag *)((char *)v20 + 2);
          }
          else
          {
            *v7 = v17 + *v5 - 127;
          }
          ++v9;
          ++v5;
          ++v7;
          --v16;
        }
        while ( v16 );
      }
      break;
    default:
      return;
  }
}
==============================================================================================================================
int __cdecl lImageCompressionParallelBitfieldSAPPHIRE_FORMAT_COMMON(
        struct ODM::image_tag *a1,
        struct ODC::iformats_header_tag *a2,
        __int16 a3)
{
  int v3; // edx
  int *v4; // ecx
  int v5; // ebx
  int *v6; // eax
  int v7; // esi
  int *v8; // ebx
  int v9; // ecx
  int v10; // ecx
  struct ODC::iformats_header_tag *v11; // edx
  _DWORD *v12; // ecx
  int v13; // ecx
  int *v14; // eax
  _DWORD *v15; // ecx
  _DWORD *v16; // edx
  int *v17; // esi
  int *v18; // eax
  int v19; // edi
  int v20; // ebx
  int v21; // eax
  int v22; // edi
  int *v23; // ecx
  int v24; // ebx
  int v25; // eax
  int v26; // ecx
  int v27; // edx
  int v28; // eax
  int v29; // ecx
  int v30; // ecx
  int v31; // eax
  _DWORD *v32; // edx
  int v33; // edi
  int v34; // edi
  bool v35; // zf
  int v36; // edi
  int *v37; // ebx
  int v38; // eax
  int v39; // eax
  bool v40; // cc
  int v41; // ebx
  _DWORD *v42; // edi
  int *v43; // esi
  size_t *v44; // edi
  int v45; // eax
  size_t v46; // ebx
  int *v47; // edx
  int v48; // edi
  int v49; // eax
  _DWORD *v50; // esi
  int *v51; // ecx
  int v52; // ebx
  int v53; // eax
  _WORD *v54; // ecx
  int *v55; // ecx
  int v57; // [esp+Ch] [ebp-CCh]
  int v58; // [esp+10h] [ebp-C8h]
  int v59; // [esp+14h] [ebp-C4h]
  _DWORD *v60; // [esp+20h] [ebp-B8h]
  int v61; // [esp+24h] [ebp-B4h]
  int v62; // [esp+28h] [ebp-B0h]
  _DWORD *v63; // [esp+2Ch] [ebp-ACh]
  int v64; // [esp+30h] [ebp-A8h]
  int v65; // [esp+38h] [ebp-A0h]
  int v66; // [esp+38h] [ebp-A0h]
  int v67; // [esp+3Ch] [ebp-9Ch]
  _DWORD *v68; // [esp+3Ch] [ebp-9Ch]
  __int16 i; // [esp+40h] [ebp-98h]
  int *v70; // [esp+40h] [ebp-98h]
  int v71; // [esp+44h] [ebp-94h]
  int v72; // [esp+44h] [ebp-94h]
  int *v73; // [esp+48h] [ebp-90h]
  int v74; // [esp+4Ch] [ebp-8Ch]
  int v75; // [esp+4Ch] [ebp-8Ch]
  int v76; // [esp+50h] [ebp-88h]
  int v77; // [esp+50h] [ebp-88h]
  int v78; // [esp+50h] [ebp-88h]
  int v79; // [esp+50h] [ebp-88h]
  int v80; // [esp+50h] [ebp-88h]
  _BYTE v81[40]; // [esp+54h] [ebp-84h] BYREF
  _DWORD v82[16]; // [esp+7Ch] [ebp-5Ch] BYREF
  char v83; // [esp+BCh] [ebp-1Ch]

  v3 = *((__int16 *)a1 + 14);
  v71 = *((__int16 *)a1 + 13);
  v4 = (int *)*((_DWORD *)a2 + 90);
  *((_DWORD *)a2 + 73) = 0;
  *((_DWORD *)a2 + 72) = 0;
  v5 = 7 * *((_DWORD *)a1 + 9) * *((__int16 *)a1 + 20);
  v73 = v4;
  v62 = v3;
  v58 = v5;
  v60 = (int *)((char *)v4 + v5);
  memset((char *)v4 + v5, 0, 4 * v3);
  if ( a3 == 7 )
  {
    v6 = (int *)*((_DWORD *)a1 + 22074);
    v7 = v62;
    v8 = (int *)(*((_DWORD *)a2 + 90) + v5 + 4 * *((__int16 *)a1 + 14));
    if ( v62 > 0 )
    {
      v67 = v62;
      do
      {
        if ( v71 > 0 )
        {
          v9 = v71;
          do
          {
            *v8++ = *v6++ >> 2;
            --v9;
          }
          while ( v9 );
        }
        --v67;
      }
      while ( v67 );
    }
  }
  else
  {
    v7 = v62;
  }
  v61 = (v71 - 1) / 16;
  v57 = (v71 - 1) % 16;
  v72 = 0;
  if ( v7 > 0 )
  {
    do
    {
      v10 = v72 * *((__int16 *)a1 + 13);
      if ( a3 == 7 )
      {
        v11 = a2;
        v12 = (_DWORD *)(*((_DWORD *)a2 + 90) + v58 + 4 * (*((__int16 *)a1 + 14) + v10));
      }
      else
      {
        v12 = (_DWORD *)(*((_DWORD *)a1 + 22074) + 4 * v10);
        v11 = a2;
      }
      v68 = v12 + 1;
      *v60 = (char *)v73 - *((_DWORD *)v11 + 90);
      v63 = v12;
      v13 = *v12;
      ++v60;
      if ( (unsigned int)(v13 + 127) > 0xFD )
      {
        if ( (unsigned int)(v13 + 0x8000) > 0xFFFF )
        {
          *(_BYTE *)v73 = -1;
          *(int *)((char *)v73 + 1) = v13;
          v14 = (int *)((char *)v73 + 5);
          ++*((_DWORD *)v11 + 73);
        }
        else
        {
          *(_BYTE *)v73 = -2;
          *(_WORD *)((char *)v73 + 1) = v13;
          v14 = (int *)((char *)v73 + 3);
          ++*((_DWORD *)v11 + 72);
        }
      }
      else
      {
        *(_BYTE *)v73 = v13 + 127;
        v14 = (int *)((char *)v73 + 1);
      }
      v73 = v14;
      v65 = 1;
      if ( v61 < 1 )
        goto LABEL_135;
      do
      {
        for ( i = 0; i < 2; ++i )
        {
          v15 = v63;
          v16 = v68;
          v17 = (int *)&v81[64 * i];
          v18 = v17;
          v19 = 8;
          do
          {
            v20 = *v16 - *v15++;
            *v18 = v20;
            ++v16;
            ++v18;
            --v19;
          }
          while ( v19 );
          v21 = *v17;
          v63 = v15;
          *(_DWORD *)&v81[64 * i + 36] = *v17;
          *(_DWORD *)&v81[64 * i + 32] = v21;
          v68 = v16;
          v22 = v21;
          v23 = (int *)&v81[64 * i + 4];
          v24 = 7;
          do
          {
            if ( *v23 > v22 )
            {
              v22 = *v23;
              *(_DWORD *)&v81[64 * i + 36] = *v23;
            }
            if ( *v23 < v21 )
            {
              v21 = *v23;
              *(_DWORD *)&v81[64 * i + 32] = *v23;
            }
            ++v23;
            --v24;
          }
          while ( v24 );
          v25 = *(_DWORD *)&v81[64 * i + 32];
          v26 = *(_DWORD *)&v81[64 * i + 36];
          if ( v25 <= 64 )
          {
            if ( v25 >= -63 )
            {
              if ( v25 <= 32 )
              {
                if ( v25 >= -31 )
                {
                  if ( v25 <= 16 )
                  {
                    if ( v25 >= -15 )
                    {
                      if ( v25 <= 8 )
                      {
                        if ( v25 >= -7 )
                        {
                          if ( v25 <= 4 )
                          {
                            if ( v25 >= -3 )
                            {
                              if ( v25 <= 2 )
                              {
                                if ( v25 >= -1 )
                                {
                                  if ( v25 == 2 )
                                    v27 = 2;
                                  else
                                    v27 = (v25 == -1) + 1;
                                }
                                else
                                {
                                  v27 = 3;
                                }
                              }
                              else
                              {
                                v27 = 3;
                              }
                            }
                            else
                            {
                              v27 = 4;
                            }
                          }
                          else
                          {
                            v27 = 4;
                          }
                        }
                        else
                        {
                          v27 = 5;
                        }
                      }
                      else
                      {
                        v27 = 5;
                      }
                    }
                    else
                    {
                      v27 = 6;
                    }
                  }
                  else
                  {
                    v27 = 6;
                  }
                }
                else
                {
                  v27 = 7;
                }
              }
              else
              {
                v27 = 7;
              }
            }
            else
            {
              v27 = 8;
            }
          }
          else
          {
            v27 = 8;
          }
          if ( v26 <= 64 )
          {
            if ( v26 >= -63 )
            {
              if ( v26 <= 32 )
              {
                if ( v26 >= -31 )
                {
                  if ( v26 <= 16 )
                  {
                    if ( v26 >= -15 )
                    {
                      if ( v26 <= 8 )
                      {
                        if ( v26 >= -7 )
                        {
                          if ( v26 <= 4 )
                          {
                            if ( v26 >= -3 )
                            {
                              if ( v26 <= 2 )
                              {
                                if ( v26 >= -1 )
                                {
                                  if ( v26 == 2 )
                                    v28 = 2;
                                  else
                                    v28 = (v26 == -1) + 1;
                                }
                                else
                                {
                                  v28 = 3;
                                }
                              }
                              else
                              {
                                v28 = 3;
                              }
                            }
                            else
                            {
                              v28 = 4;
                            }
                          }
                          else
                          {
                            v28 = 4;
                          }
                        }
                        else
                        {
                          v28 = 5;
                        }
                      }
                      else
                      {
                        v28 = 5;
                      }
                    }
                    else
                    {
                      v28 = 6;
                    }
                  }
                  else
                  {
                    v28 = 6;
                  }
                }
                else
                {
                  v28 = 7;
                }
              }
              else
              {
                v28 = 7;
              }
            }
            else
            {
              v28 = 8;
            }
          }
          else
          {
            v28 = 8;
          }
          if ( v27 >= v28 )
            v28 = v27;
          v82[16 * i] = v28;
          v29 = v17[10];
          if ( v29 > 4 )
          {
            switch ( v29 )
            {
              case 5:
                v59 = 31;
                v75 = 15;
                break;
              case 6:
                v59 = 63;
                v75 = 31;
                break;
              case 7:
                v59 = 127;
                v75 = 63;
                break;
              default:
                v59 = 255;
                v75 = 127;
                break;
            }
            v17[12] = 0;
            v17[13] = 0;
            if ( v29 == 8 )
            {
              v36 = 0;
              v37 = (int *)&v81[64 * i];
              v77 = 8;
              do
              {
                v38 = *v37;
                if ( *v37 < -127 || v38 > 126 )
                {
                  if ( v38 < -32768 || (v40 = v38 <= 0x7FFF, v39 = 254, !v40) )
                    v39 = 255;
                }
                else
                {
                  v39 = v75 + v38;
                }
                *((_QWORD *)v17 + 6) |= (unsigned __int64)(v59 & (unsigned int)v39) << v36;
                ++v37;
                v36 += 8;
                --v77;
              }
              while ( v77 );
            }
            else
            {
              v41 = 0;
              v42 = &v81[64 * i];
              v78 = 8;
              do
              {
                *((_QWORD *)v17 + 6) |= (unsigned __int64)(v59 & (unsigned int)(v75 + *v42)) << v41;
                v41 += v17[10];
                ++v42;
                --v78;
              }
              while ( v78 );
            }
          }
          else
          {
            switch ( v29 )
            {
              case 1:
                v64 = 1;
                v74 = 0;
                break;
              case 2:
                v64 = 3;
                v74 = 1;
                break;
              case 3:
                v64 = 7;
                v74 = 3;
                break;
              default:
                v64 = 15;
                v74 = 7;
                break;
            }
            v30 = 0;
            v17[14] = 0;
            v31 = 0;
            v32 = &v81[64 * i];
            v76 = 8;
            do
            {
              v33 = v74 + *v32++;
              v34 = (v64 & v33) << v30;
              v30 += v17[10];
              v31 |= v34;
              v35 = v76-- == 1;
              v17[14] = v31;
            }
            while ( !v35 );
          }
        }
        *(_BYTE *)v73 = LOBYTE(v82[0]) | (16 * v83);
        v43 = (int *)((char *)v73 + 1);
        v44 = v82;
        v79 = 2;
        do
        {
          v45 = *v44;
          if ( (int)*v44 > 4 )
          {
            if ( v45 <= 0 )
              goto LABEL_123;
            v46 = *v44;
            memcpy(v43, v44 + 2, *v44);
          }
          else
          {
            if ( v45 <= 0 )
              goto LABEL_123;
            v46 = *v44;
            memcpy(v43, v44 + 4, *v44);
          }
          v43 = (int *)((char *)v43 + v46);
LABEL_123:
          v44 += 16;
          --v79;
        }
        while ( v79 );
        v70 = (int *)v81;
        v80 = 2;
        do
        {
          v47 = v70;
          v48 = 8;
          do
          {
            v49 = *v47;
            if ( *v47 < -127 || v49 > 126 )
            {
              if ( v49 < -32768 || v49 > 0x7FFF )
              {
                *v43++ = v49;
                ++*((_DWORD *)a2 + 73);
              }
              else
              {
                *(_WORD *)v43 = v49;
                v43 = (int *)((char *)v43 + 2);
                ++*((_DWORD *)a2 + 72);
              }
            }
            ++v47;
            --v48;
          }
          while ( v48 );
          v70 += 16;
          --v80;
        }
        while ( v80 );
        v73 = v43;
        ++v65;
      }
      while ( v65 <= v61 );
LABEL_135:
      if ( v57 >= 1 )
      {
        v50 = v63;
        v51 = v73;
        v52 = (char *)v68 - (char *)v63;
        v66 = v57;
        while ( 1 )
        {
          v53 = *(_DWORD *)((char *)v50 + v52) - *v50;
          if ( (unsigned int)(v53 + 127) > 0xFD )
          {
            if ( (unsigned int)(v53 + 0x8000) > 0xFFFF )
            {
              *(_BYTE *)v51 = -1;
              v55 = (int *)((char *)v51 + 1);
              *v55 = v53;
              v51 = v55 + 1;
              ++*((_DWORD *)a2 + 73);
            }
            else
            {
              *(_BYTE *)v51 = -2;
              v54 = (_WORD *)((char *)v51 + 1);
              *v54 = v53;
              v51 = (int *)(v54 + 1);
              ++*((_DWORD *)a2 + 72);
            }
          }
          else
          {
            *(_BYTE *)v51 = v53 + 127;
            v51 = (int *)((char *)v51 + 1);
          }
          ++v50;
          if ( !--v66 )
            break;
          v52 = (char *)v68 - (char *)v63;
        }
        v73 = v51;
      }
      ++v72;
    }
    while ( v72 < v62 );
  }
  return (int)v73 - *((_DWORD *)a2 + 90);
}
==============================================================================================================================
void __cdecl pImageDecompressionBitfieldParallelSAPPHIRE_FORMAT_COMMON(
        struct ODM::error_tag *a1,
        struct ODM::image_tag *a2,
        struct ODC::iformats_header_tag *a3,
        int a4)
{
  int v4; // eax
  _DWORD v5[3]; // [esp+0h] [ebp-20h] BYREF
  __int16 v6; // [esp+Ch] [ebp-14h]
  _DWORD v7[4]; // [esp+10h] [ebp-10h] BYREF

  v7[0] = a2;
  v7[2] = a4;
  v7[1] = a3;
  v4 = *((__int16 *)a3 + 159);
  v6 = 0;
  v7[3] = 1;
  v5[0] = v7;
  v5[1] = 0;
  v5[2] = v4;
  ((void (__thiscall *)(_DWORD *))sub_100551C0)(v5);
}
==============================================================================================================================
int __usercall sub_100551C0@<eax>(int result@<eax>, int a2@<ecx>)
{
  _DWORD *v3; // ecx
  int v4; // ecx
  int *v5; // edx
  int v6; // eax
  unsigned __int8 v7; // cl
  int v8; // ecx
  _BYTE *v9; // eax
  int v10; // edx
  __int16 *v11; // ecx
  int *v12; // eax
  int v13; // edi
  int v14; // edx
  int v15; // esi
  int *v16; // esi
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // edi
  int v21; // eax
  int *v22; // edx
  int v23; // ecx
  bool v24; // zf
  int v25; // eax
  int v26; // eax
  char v27; // bl
  int *v28; // edi
  int v29; // eax
  int v30; // edi
  int *v31; // ebx
  __int64 v32; // rax
  int *v33; // eax
  int *v34; // ecx
  __int16 *v35; // esi
  int *v36; // edi
  int v37; // edx
  int v38; // edx
  int v39; // edx
  int *v40; // ecx
  int v41; // edi
  _BYTE *v42; // eax
  unsigned __int8 v43; // dl
  int v44; // edx
  int v45; // ebx
  int v46; // edx
  int v47; // ecx
  _DWORD *v48; // eax
  int i; // esi
  int v50; // [esp+Ch] [ebp-C0h]
  int v51; // [esp+10h] [ebp-BCh]
  int v52; // [esp+14h] [ebp-B8h]
  int v53; // [esp+1Ch] [ebp-B0h]
  _DWORD *v54; // [esp+20h] [ebp-ACh]
  int v55; // [esp+24h] [ebp-A8h]
  int *v56; // [esp+28h] [ebp-A4h]
  int v57; // [esp+2Ch] [ebp-A0h]
  int v58; // [esp+30h] [ebp-9Ch]
  int *v59; // [esp+34h] [ebp-98h]
  int v60; // [esp+38h] [ebp-94h]
  int v61; // [esp+38h] [ebp-94h]
  _BYTE *v62; // [esp+3Ch] [ebp-90h]
  __int16 *v63; // [esp+3Ch] [ebp-90h]
  int v64; // [esp+40h] [ebp-8Ch]
  int v65; // [esp+40h] [ebp-8Ch]
  int v66; // [esp+40h] [ebp-8Ch]
  _BYTE *v67; // [esp+40h] [ebp-8Ch]
  int v68; // [esp+44h] [ebp-88h]
  int v69; // [esp+44h] [ebp-88h]
  int v70; // [esp+44h] [ebp-88h]
  _BYTE v71[40]; // [esp+48h] [ebp-84h] BYREF
  _DWORD v72[22]; // [esp+70h] [ebp-5Ch] BYREF

  v3 = *(_DWORD **)a2;
  v58 = a2;
  v54 = v3;
  if ( *(_DWORD *)(*v3 + 88296) )
  {
    v50 = v3[2] + *(_DWORD *)(v3[1] + 360);
    v4 = *(__int16 *)(*v3 + 26) - 1;
    v53 = v4 / 16;
    v51 = v4 % 16;
    v57 = *(_DWORD *)(a2 + 4);
    if ( v57 < *(_DWORD *)(a2 + 8) )
    {
      do
      {
        v5 = (int *)(*(_DWORD *)(*v54 + 88296) + 4 * v57 * *(__int16 *)(*v54 + 26));
        v56 = v5 + 1;
        v6 = *(_DWORD *)(v54[1] + 360) + *(_DWORD *)(v50 + 4 * v57);
        v59 = v5;
        v7 = *(_BYTE *)v6;
        if ( *(_BYTE *)v6 >= 0xFEu )
        {
          if ( v7 == 0xFF )
          {
            v8 = *(_DWORD *)(v6 + 1);
            v9 = (_BYTE *)(v6 + 5);
          }
          else
          {
            v8 = *(__int16 *)(v6 + 1);
            v9 = (_BYTE *)(v6 + 3);
          }
        }
        else
        {
          v8 = v7 - 127;
          v9 = (_BYTE *)(v6 + 1);
        }
        *v5 = v8;
        v62 = v9;
        if ( v53 >= 1 )
        {
          v55 = v53;
          do
          {
            v10 = *v62 & 0xF;
            v11 = (__int16 *)(v62 + 1);
            v72[16] = (unsigned __int8)*v62 >> 4;
            v72[0] = v10;
            v12 = v72;
            v13 = 2;
            do
            {
              v14 = *v12;
              v15 = 0;
              if ( *v12 > 4 )
              {
                if ( v14 > 0 )
                {
                  do
                  {
                    *((_BYTE *)v12 + v15++ + 8) = *(_BYTE *)v11;
                    v11 = (__int16 *)((char *)v11 + 1);
                  }
                  while ( v15 < *v12 );
                }
              }
              else if ( v14 > 0 )
              {
                do
                {
                  *((_BYTE *)v12 + v15++ + 16) = *(_BYTE *)v11;
                  v11 = (__int16 *)((char *)v11 + 1);
                }
                while ( v15 < *v12 );
              }
              v12 += 16;
              --v13;
            }
            while ( v13 );
            v63 = v11;
            v16 = v72;
            v60 = 2;
            do
            {
              v17 = *v16;
              if ( *v16 > 4 )
              {
                v25 = v17 - 5;
                if ( v25 )
                {
                  v26 = v25 - 1;
                  if ( v26 )
                  {
                    if ( v26 == 1 )
                    {
                      v52 = 127;
                      v69 = 63;
                    }
                    else
                    {
                      v52 = 255;
                      v69 = 127;
                    }
                  }
                  else
                  {
                    v52 = 63;
                    v69 = 31;
                  }
                }
                else
                {
                  v52 = 31;
                  v69 = 15;
                }
                if ( *v16 == 8 )
                {
                  v27 = 0;
                  v28 = v16 - 10;
                  v65 = 8;
                  do
                  {
                    v29 = v52 & (*((__int64 *)v16 + 1) >> (v27 * *(_BYTE *)v16));
                    if ( v29 == 255 )
                    {
                      *v28 = 0x7FFFFFFF;
                    }
                    else if ( v29 == 254 )
                    {
                      *v28 = 0x80000000;
                    }
                    else
                    {
                      *v28 = v29 - v69;
                    }
                    ++v27;
                    ++v28;
                    --v65;
                  }
                  while ( v65 );
                }
                else
                {
                  v30 = 0;
                  v31 = v16 - 10;
                  v66 = 8;
                  do
                  {
                    v32 = *((__int64 *)v16 + 1) >> ((unsigned __int8)v30++ * *(_BYTE *)v16);
                    ++v31;
                    v24 = v66-- == 1;
                    *(v31 - 1) = (v52 & v32) - v69;
                  }
                  while ( !v24 );
                }
              }
              else
              {
                v18 = v17 - 1;
                if ( v18 )
                {
                  v19 = v18 - 1;
                  if ( v19 )
                  {
                    if ( v19 == 1 )
                    {
                      v20 = 7;
                      v68 = 3;
                    }
                    else
                    {
                      v20 = 15;
                      v68 = 7;
                    }
                  }
                  else
                  {
                    v20 = 3;
                    v68 = 1;
                  }
                }
                else
                {
                  v20 = 1;
                  v68 = 0;
                }
                v21 = 0;
                v22 = v16 - 10;
                v64 = 8;
                do
                {
                  v23 = v21 * *v16;
                  ++v21;
                  ++v22;
                  v24 = v64-- == 1;
                  *(v22 - 1) = (v20 & (v16[4] >> v23)) - v68;
                }
                while ( !v24 );
              }
              v16 += 16;
              --v60;
            }
            while ( v60 );
            v33 = v59;
            v34 = v56;
            v35 = v63;
            v36 = (int *)v71;
            v67 = v71;
            v70 = 2;
            do
            {
              v61 = 8;
              do
              {
                v37 = *v36;
                if ( *v36 == 0x7FFFFFFF )
                {
                  v38 = *(_DWORD *)v35 + *v33;
                  v35 += 2;
                  *v34 = v38;
                }
                else if ( v37 == 0x80000000 )
                {
                  v39 = *v33 + *v35++;
                  *v34 = v39;
                }
                else
                {
                  *v34 = v37 + *v33;
                }
                ++v33;
                ++v34;
                ++v36;
                --v61;
              }
              while ( v61 );
              v36 = (int *)(v67 + 64);
              v24 = v70-- == 1;
              v67 += 64;
            }
            while ( !v24 );
            v24 = v55-- == 1;
            v56 = v34;
            v59 = v33;
            v62 = v35;
          }
          while ( !v24 );
        }
        if ( v51 >= 1 )
        {
          v40 = v59;
          v41 = v51;
          v42 = v62;
          do
          {
            v43 = *v42;
            if ( *v42 >= 0xFEu )
            {
              if ( v43 == 0xFF )
              {
                v44 = *(_DWORD *)(v42 + 1) + *v40;
                v42 += 5;
              }
              else
              {
                v44 = *v40 + *(__int16 *)(v42 + 1);
                v42 += 3;
              }
            }
            else
            {
              v44 = v43 + *v40 - 127;
              ++v42;
            }
            *(int *)((char *)v40++ + (char *)v56 - (char *)v59) = v44;
            --v41;
          }
          while ( v41 );
        }
        ++v57;
      }
      while ( v57 < *(_DWORD *)(v58 + 8) );
    }
    result = 7;
    if ( *(_WORD *)(v54[1] + 352) == 7 )
    {
      result = v58;
      v45 = *(_DWORD *)(v58 + 4);
      if ( v45 < *(_DWORD *)(v58 + 8) )
      {
        v46 = *v54;
        v47 = *(__int16 *)(*v54 + 26);
        do
        {
          v48 = (_DWORD *)(*(_DWORD *)(v46 + 88296) + 4 * v45 * v47);
          for ( i = 0; i < v47; ++v48 )
          {
            *v48 *= 4;
            v46 = *v54;
            v47 = *(__int16 *)(*v54 + 26);
            ++i;
          }
          result = v58;
          ++v45;
        }
        while ( v45 < *(_DWORD *)(v58 + 8) );
      }
    }
    *(_WORD *)(v58 + 12) = 1;
  }
  return result;
}
==============================================================================================================================


==============================================================================================================================


==============================================================================================================================



